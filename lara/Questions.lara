
import weaver.Query;
import weaver.Selector;

/**
 *  LARA Questions
 */
aspectdef Questions


	// Implement signature in Kadabra








	//---------------__///

	// Sonarqube Community version does not support C++

	// Kadabra (Java) does not have memberCall, memberAccess, Bases?
	
	// Jackdaw (JS) does not have the  weaver.Query API?


	// memberAccess get base class
	var fieldsAccessed = Query.search('method', 'accessTest').search('memberAccess').get(); // TODO; memberAccess must belong to class


	for(var fieldAccessed of fieldsAccessed) {
		println("Code: " + fieldAccessed.code);
		println("Type: " + fieldAccessed.base.type.name); // works for 2 and 4
		println("BASE0: " + fieldAccessed.base.joinPointType); //  atal.age
		if(fieldAccessed.base.decl !== undefined)
					println("BASE1: " + fieldAccessed.base.decl.name); // this.age
				else
					if (fieldAccessed.base.vardecl !== undefined)
						println("BASE2: " + fieldAccessed.base.vardecl.type.name); //  atal.age
					else if (fieldAccessed.base.type.pointee !== undefined)
						println("BASE3: " + fieldAccessed.base.type.pointee.decl.name); // (this->at)->age
					else println("BASE4: " + fieldAccessed.base.type.name); //  (this->ata).age
		println();
	
	}


	// Wierd search vars
		/*
	var methodFieldsMap = new Map();
	println($class.name);

	for ($method of Query.searchFromInclusive($class).search("method").get()){
		println("	" + $method.name);
		var fieldsAccessed = []; // TODO : Maybe change to Set
		for ($var of Query.searchFromInclusive($method).search("var").get()){
			println("		" + $var.name);
			
				if($var.isField && $var.declaration)  // check if var.decl is  not undefined Ex: (PrintStream)
					if($var.declaration.parent.name === $class.name)
						fieldsAccessed.push($var.declaration.name);
		
		}
		println();

		methodFieldsMap.set($method.name, fieldsAccessed);

	}
	*/ 

	
	var methodFieldsMap = new Map();
	println($class.name);

	for (query of Query.searchFromInclusive($class).search("method").search("var").chain()){
		println("	" + query["method"].name);
		println("	" + query["var"].name);
		//println("	" + query["var"].parent.srcCode);
		println();
		//println("	" + query["method"].name);
		

	}
	/**/
	

	

     

/*
     	var fieldsAccessesByMethod = Query.searchFrom($method.definitionJp,"memberAccess").get(); // TODO; memberAccess must belong to class


		for(fieldAccessesByMethod of fieldsAccessesByMethod){
			if(fieldAccessesByMethod.base.decl !== undefined)
				continue;				
			println("METHOD: " + $method.signature);
			println("BASE: " + fieldAccessesByMethod.getCode());

			// GET CLASS
			if(fieldAccessesByMethod.base.decl !== undefined)
				println("BASE: " + fieldAccessesByMethod.base.decl.name); // this.bar1()
			else
				println("BASE: " + fieldAccessesByMethod.base.vardecl.type); // myAnimal.animalSound

				memberAccess.base.type.pointee.decl

		//throw statements, switch, case, default, 
	// ? ternary operator, 
	//catch, break, continue, goto.

				*/


	/* How to get field accesses
	for (c of Query.search("class").search("method").search("var").chain()){
		println("class: " + c["class"].name);
		println("method: " + c["method"].name);
		println("var: " + c["var"].name);
		if(c["var"].isField){
			println("declaration: " + c["var"].declaration); // FIELD
			if(c["var"].declaration){
				println("parent: " + c["var"].declaration.parent); // CLASS
			}


		}
	*/			
end