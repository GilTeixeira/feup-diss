import Metrics.Metric;

/**
 * Measures the Cyclomatic complexity
 * @constructor
 */
function CycloComplex() {
	var id = "OO-CyC";
	var name = "Cyclomatic complexity";
	var sigla = "CycloComplex";
	var author = "Thomas J. McCabe";
	var year = 1976;
	var description = "Cyclomatic complexity (CC) measures the number of linearly independent paths through a program's source code.";

    // Parent constructor    
    Metric.call(this, id, name, sigla, author, year, description);

}

// Inheritance
CycloComplex.prototype = Object.create(Metric.prototype);

//CycloComplex.prototype.calculateForClass = function($class) {

CycloComplex.prototype.calculateForProject = function() {
	var value = 0;
	for ($file of  Query.search("file"))
		value += this.calculateForFile($file);
	return value;
}


CycloComplex.prototype.calculateForJoinPoint = function($jp) {
	var complexityCounter = 0;

	complexityCounter += $jp.instanceOf('if')?1:0;
	complexityCounter += $jp.instanceOf('loop')?1:0;
	complexityCounter += $jp.instanceOf('ternary')?1:0;
	complexityCounter += ($jp.instanceOf('case') && !$jp.instanceOf('default'))?1:0;  // already includes defaults
	//complexityCounter += $jp.instanceOf('switch')?1:0;
	complexityCounter += ($jp.instanceOf('binary')&& ($jp.kind === '&&' || $jp.kind === '||'))?1:0;
	//complexityCounter += $jp.instanceOf('try')?1:0;  // try catch are 1
	//complexityCounter += $jp.instanceOf('throw')?1:0;
	//complexityCounter += $jp.instanceOf('break')?1:0;
	//complexityCounter += $jp.instanceOf('continue')?1:0;
	complexityCounter += $jp.instanceOf('goto')?1:0;
	complexityCounter += ($jp.instanceOf('function') && $jp.hasBody)?1:0;
	complexityCounter += $jp.instanceOf('lambda')?1:0;

	return complexityCounter;

}

CycloComplex.prototype.calculateForFile = function($file) {
	var complexityCounter = 0;
	//println("Counters:");

	for(jp of $file.descendants){
		complexityCounter += this.calculateForJoinPoint(jp);	
	
	}
	
	return complexityCounter;
}

CycloComplex.prototype.calculateForClass = function($class) {
	var complexityCounter = 0;
	for ($method of $class.allMethods){
		complexityCounter += this.calculateForFunction($method);
		complexityCounter++;
	}

	return complexityCounter;
}



CycloComplex.prototype.calculateForFunction = function($function) {
	var complexityCounter = 0;
	//println("Counters:");

	for(jp of $function.descendants){
		complexityCounter += this.calculateForJoinPoint(jp);	
	}
	
	return complexityCounter;
}

CycloComplex.prototype.calculateForFunctionv2 = function($function) {
	var complexityCounter = 0;
	//println("Counters:");

	for(jp of $function.descendants){

		if(jp.instanceOf('if') || jp.instanceOf('loop') || jp.instanceOf('ternary') ||
		jp.instanceOf('case') || jp.instanceOf('switch') || (jp.instanceOf('binary') && (jp.kind === '&&' || jp.kind === '||')) ||
		jp.instanceOf('try') || jp.instanceOf('throw') || jp.instanceOf('break') || jp.instanceOf('continue') || jp.instanceOf('goto'))
			complexityCounter++;
		
	
	
	}
	
	return complexityCounter;
}


CycloComplex.prototype.calculateForFunctionv0 = function($function) {
	var complexityCounter = 0;
	//println("Counters:");
	
	complexityCounter += Query.searchFrom($function, 'if').get().length;
	complexityCounter += Query.searchFrom($function, 'loop').get().length;
	complexityCounter += Query.searchFrom($function, 'ternary').get().length;
	complexityCounter += Query.searchFrom($function, 'case').get().length; // already includes defaults
	complexityCounter += Query.searchFrom($function, 'switch').get().length;
	complexityCounter += Query.searchFrom($function, 'binary',{"kind": kind => kind === '&&' || kind === '||'}).get().length;
	complexityCounter += Query.searchFrom($function, 'try').get().length; // try catch are 1
	complexityCounter += Query.searchFrom($function, 'throw').get().length;
	complexityCounter += Query.searchFrom($function, 'break').get().length;
	complexityCounter += Query.searchFrom($function, 'continue').get().length;
	complexityCounter += Query.searchFrom($function, 'goto').get().length;

	return complexityCounter;
}
/*
CycloComplex.prototype.calculateForFunctionOld = function($function) {
	var complexityCounter = 0;

	complexityCounter += Query.searchFrom($function, 'if').get().length;
	complexityCounter += Query.searchFrom($function, 'loop').get().length;
	var binaryLogicOps = ["l_and", "l_or"];
	complexityCounter += Query.searchFrom($function, 'binaryOp', {"kind": $kind => binaryLogicOps.includes($kind)}).get().length;
	
	// The complexity gets incremented by one for: 
	//x// function definitions, 
	//x// while, do while, for, 
	//throw statements, switch, case, default, 
	//x// && operator, || operator, 
	// ? ternary operator, 
	//catch, break, continue, goto.



	return complexityCounter;
}
*/