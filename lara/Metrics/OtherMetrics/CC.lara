import Metrics.Metric;

/**
 * Measures the Cyclomatic complexity
 * @constructor
 */
function CC() {
	var name = "Cyclomatic complexity";
	var sigla = "CC";
	var author = "Thomas J. McCabe";
	var year = 1976;
	var description = "Cyclomatic complexity (CC) measures the number of linearly independent paths through a program's source code.";

    // Parent constructor    
    Metric.call(this, name, sigla, author, year, description);

}

// Inheritance
CC.prototype = Object.create(Metric.prototype);

CC.prototype.calculateForFunction = function($function) {
	var complexityCounter = 0;
	
	var stmtStack = [];
	$function.stmts.forEach(stmt => stmtStack.push({'stmt':stmt,'nesting':0}));

    while (stmtStack.length !== 0) 
    { 
    	var stmtTop =  stmtStack.shift();
    	var stmt = stmtTop.stmt;
    	var nesting = stmtTop.nesting;

    	//if(!stmt.instanceOf('stmt'))
		//		continue;

    	if(stmt.instanceOf('if') || stmt.instanceOf('loop') || stmt.instanceOf('ternary') || stmt.instanceOf('switch')){
    		nesting++;
    		println(nesting);
    		complexityCounter += nesting;
    		
    		
    	}
		// depth first search
    	stmt.children.slice().reverse().forEach(stmtChild => stmtStack.unshift({'stmt':stmtChild,'nesting':nesting}));

    } 

	return complexityCounter;
}


CC.prototype.calculateForFunctionv0 = function($function) {
	var complexityCounter = 0;
	//println("Counters:");
	
	complexityCounter += Query.searchFrom($function, 'if').get().length;
	complexityCounter += Query.searchFrom($function, 'loop').get().length;
	complexityCounter += Query.searchFrom($function, 'ternary').get().length;
	complexityCounter += Query.searchFrom($function, 'case').get().length;
	complexityCounter += Query.searchFrom($function, 'switch').get().length;
	complexityCounter += Query.searchFrom($function, 'binary',{"kind": kind => kind === '&&' || kind === '||'}).get().length;

	// catch
	// break
	// continue
	// goto
	// default
	// throw
	return complexityCounter;
}

CC.prototype.calculateForFunctionOld = function($function) {
	var complexityCounter = 0;

	complexityCounter += Query.searchFrom($function, 'if').get().length;
	complexityCounter += Query.searchFrom($function, 'loop').get().length;
	var binaryLogicOps = ["l_and", "l_or"];
	complexityCounter += Query.searchFrom($function, 'binaryOp', {"kind": $kind => binaryLogicOps.includes($kind)}).get().length;
	
	// The complexity gets incremented by one for: 
	//x// function definitions, 
	//x// while, do while, for, 
	//throw statements, switch, case, default, 
	//x// && operator, || operator, 
	// ? ternary operator, 
	//catch, break, continue, goto.



	return complexityCounter;
}
