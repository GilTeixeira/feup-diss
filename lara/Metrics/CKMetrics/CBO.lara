import Metrics.Metric;

/**
 * Measures the Coupling between Object Classes
 * @constructor
 */
function CBO() {
	var name = "Coupling between Object Classes";
	var sigla = "CBO";
	var author = "Chidamber and Kemerer";
	var year = 1994;
	var description = "Coupling between Object Classes (CBO) measures the number of classes to which a class is coupled.";

    // Parent constructor    
    Metric.call(this, name, sigla, author, year, description);
}

// Inheritance
CBO.prototype = Object.create(Metric.prototype);


// Override

CBO.prototype.calculateForClass = function($class) {

	var classesCoupled = new Set();

	var memberAccesses = [];
	var $varDecls = [];

	var typesUsed = [];

	for(jp of $class.descendants){
		if(jp.instanceOf("fieldRef") || jp.instanceOf("memberCall"))
			memberAccesses.push(jp);

		if(jp.instanceOf("varDecl"))
			$varDecls.push(jp);

	}

	//println(memberAccesses.length);
	//println($varDecls.length);


	memberAccesses = memberAccesses.filter(memberAccess=> memberAccess.class.id !== $class.id && memberAccess.class.isCustom);	
	memberAccesses.forEach(memberAccess => classesCoupled.add(memberAccess.class.id));

	//var $varDecls = Query.searchFrom($class).search("varDecl").get();
	$varDecls.forEach($varDecl => typesUsed.push($varDecl.type.usedTypes));


	$class.methods.forEach($method => {
		typesUsed.push($method.returnType.usedTypes);
	});		

		
	typesUsed = typesUsed.filter($type => $type.isClass && $type.decl.id !== $class.id && $type.class.isCustom);
	typesUsed.forEach($type => classesCoupled.add($type.decl.id));

	
	//classesCoupled.forEach(classesCoupled => println(classesCoupled));
	return classesCoupled.size;

	



}

/*
CBO.prototype.calculateForClassv0 = function($class) {
	//The Coupling Between Object classes metric represents the number of classes coupled to a given class. This coupling can happen throuhg:


    
	
    




	var classesCoupled = new Set();

	//(DONE) class extends
	//$class.allSuperClasses.forEach($classSuper => classesCoupled.add($classSuper.id));



	//(DONE) method call, field accesses
	var $fieldRefs = Query.searchFrom($class).search("fieldRef").get();
	//println($fieldRefs.length);
	$fieldRefs = $fieldRefs.filter($fieldRef=> $fieldRef.class.id !== $class.id && $fieldRef.class.isCustom);
	//println($fieldRefs.length);
	$fieldRefs.forEach($fieldRef => classesCoupled.add($fieldRef.class.id));


	var $memberCalls = Query.searchFrom($class).search("memberCall").get();
	$memberCalls = $memberCalls.filter($memberCall=> $memberCall.class.id !== $class.id && $memberCall.class.isCustom);
	$memberCalls.forEach($memberCall => classesCoupled.add($memberCall.class.id));


	var typesUsed = [];

	var $params = Query.searchFrom($class).search("param").get();
	$params.forEach($param => {
		typesUsed.push($param.type.usedTypes);
	});		

	
	






	var $fields = Query.searchFromInclusive($class).search("field").get();
	$fields.forEach($field => {
		typesUsed.push($field.type.usedTypes);
	});	



	//(DONE)return types
	
	$class.methods.forEach($method => {
		typesUsed.push($method.returnType.usedTypes);
	});		

	
	//(DONE) variables in methods
	var $varDecls = Query.searchFrom($class).search("varDecl").get();
	$varDecls.forEach($varDecl => {
		typesUsed.push($varDecl.type.usedTypes);
	});	
	


	
	
	
	typesUsed = typesUsed.filter($type => $type.isClass && $type.decl.id !== $class.id && $type.class.isCustom);
	typesUsed.forEach($type => classesCoupled.add($type.decl.id));

	
	//classesCoupled.forEach(classesCoupled => println(classesCoupled));
	return classesCoupled.size;


}


CBO.prototype.calculateForClassInd2 = function($class) {
	//println("Class: " + $class.name);

   // The Coupling Between Object classes metric represents the number of classes coupled to a given class. This coupling can happen throuhg:
    // x / method call (TODO check call of constructors)
    // x/ class extends (TODO only checking the superClass)
    // x / properties or parameters
    // x/ method arguments, or return types
    // x / variables in methods

    // Call of constructors


	// CPP TYPES
	//// adjustedType
	//// arrayType
	//// 
	//// 
	//// 
    

    
	var classesCoupled = new Set();
	
    	for (var $method of Query.searchFromInclusive($class).search("method").get()){
    		//println($method.signature);
    		//println($class.methods.length);
		
		var $methodsCalled = MetricQuery.getMethodsCalled($method);
		$methodsCalled = $methodsCalled.filter($methodCalled=> $methodCalled.parent.name !== $class.name);
		for (var $methodCalled of $methodsCalled)
			classesCoupled.add($methodCalled.parent.name);

		var $classesUsed = MetricQuery.usedClasses($method.returnRef);  // TODO : This is gonna explode in Java //TODO:
		$classesUsed.forEach($classUsed => classesCoupled.add($classUsed.name));


	}
	


	for (var $field of Query.searchFromInclusive($class).search("field").get()){
		//println("$field: " + $field);
		//println("$class: " + $class);
		var $classesUsed = MetricQuery.usedClasses($field.typeReference);                      //TODO:
		$classesUsed.forEach($classUsed => classesCoupled.add($classUsed.name));

	}

	for (var $field of Query.searchFrom($class).search("localVariable").get()){         //TODO:
		println("vardecl : " + $field.code);
		println("type : " + $field.typeReference);
		//println("$type : " + $field.type); 
		var $classesUsed = MetricQuery.usedClasses($field.typeReference);       //TODO:
		println("$classesUsed : " + $classesUsed);
		$classesUsed.forEach($classUsed => classesCoupled.add($classUsed.name));

	}

	var $classesInherited = MetricQuery.getSuperClasses($class);
	for ($classInherited of $classesInherited)
		classesCoupled.add($classInherited.name); 
		
	
	//for (var $field of Query.searchFromInclusive($class).search("vardecl").get()){
//		var $classesUsed = MetricQuery.usedClasses($field.type);
		//$classesUsed.forEach($classUsed => classesCoupled.add($classUsed.name));

	//}
	
		



	
	for (var $field of Query.searchFromInclusive($class).search("field", "myobject4").get()){

		
		// if($field.type.isBuiltin)
		// 	continue;

		// if($field.type.kind === 'RecordType')
		// 	continue;

		
		// if($field.type.isArray)
		// 	continue;

		// if($field.type.kind === 'TemplateTypeParmType')
		// 	continue;

		// if($field.type.isPointer)
		// 	continue;	
		
		//println("Field: " + $field.name);
		//var usedClasses = MetricQuery.usedClasses($field.type);
		//for (usedClass of usedClasses)
			//println('used: ' + usedClass.name);
		
		// for(var $class2 of Query.search("class").get()) {
		// 	if(MetricQuery.usesClass($field.type, $class2))
		// 		println('used: ' + $class2.name);
			
		// }
		
		//println();
		}
		

		
		// println("Field: " + $field.name);
		// println("typeReference: " + $field.typeReference);
		// try{
		// // Java
		// //var decl = $field.typeReference.declaration;

		// // C
		// println("decl: " + $field.decl);
		// println("type: " + $field.type.kind);
		// var decl = $field.type.decl;
		// println(decl);
		// }
		// catch(err) {
		// println(decl);
		// }
		// println();
		

	

	var methodCallChain = Query.searchFromInclusive($class).search("method").search("vardecl").get();

	
	// for (var $vardecl of methodCallChain){
	// 	println("name: " + $vardecl.name);
	// 	println("type: " + $vardecl.type.builtinKind);
	// }
	

	

	
	//println("classesCoupled: " + Array.from(classesCoupled));
	//println();
	return classesCoupled.size;
}

// Override
CBO.prototype.calculateForClassCpp = function($class) {

	var classesCoupled = new Set();

	// Methods called by the methods of $class
	var methodsCalled = Query.search("method", {"record": r => r.name === $class.name}).search("memberCall").get();

	//println("\nFunctions Called");
	//functionsCalled.forEach(functionCalled => println(functionCalled.name));

	// Filter functions and operator<< (cout), only methods required
	// var methodsCalled = functionsCalled.filter(func => func.definition && func.definition.record);

	//println("\n Methods Called");
	//methodsCalled.forEach(methodCalled => println(methodCalled.name));

	// do not include self class
	methodsCalled.forEach(methodCalled=>{
		var classCoupled = methodCalled.definition.record.name;
		if(classCoupled !== $class.name)
			classesCoupled.add(classCoupled); 
  		
	});

	//print(classesCoupled.values()+ "\n");

	// Methods that call the methods of $class
	var methodsThatCall = Query.search("method").search("memberCall", 
		{"definition": d => d.record.name === $class.name}).chain();

	//println("\Methods that call method of class:");
	for(var query of methodsThatCall) {
		if(query["method"].record.name !== $class.name)
			classesCoupled.add(query["method"].record.name);

		//println(query["method"].record.name);
		//println();
	}

	// TODO: fields accesses

	// Fields Accessed by the methods of $class
	var fieldsAccessed = Query.search("method", {"record": r => r.name === $class.name}).search("memberAccess").get();

	
	// for(var fieldAccessed of fieldsAccessed) {
	// println("Code: " + fieldAccessed.code);
	// println("Type: " + fieldAccessed.base.type.name);
	// if(fieldAccessed.base.decl !== undefined)
	// 			println("BASE1: " + fieldAccessed.base.decl.name); // this.bar1()
	// 		else
	// 			if (fieldAccessed.base.vardecl !== undefined)
	// 				println("BASE2: " + fieldAccessed.base.vardecl.type.name); // myAnimal.animalSound
	// 			else if (fieldAccessed.base.type.pointee !== undefined)
	// 				println("BASE3: " + fieldAccessed.base.type.pointee.decl.name); // (this->ancestor)->age
	// 			else println("BASE4: " + fieldAccessed.base.type.name); // (this->ancestor).age
	
	// }

	// println();
	
	








	///......................::///

	// Methods that call the methods of $class
	var methodsThatCall = Query.search("method").search("memberCall", 
		{"definition": d => d.record.name === $class.name}).chain();

	//println("\Methods that call method of class:");
	for(var query of methodsThatCall) {
		if(query["method"].record.name !== $class.name)
			classesCoupled.add(query["method"].record.name);

		//println(query["method"].record.name);
		//println();
	}


	

	return classesCoupled.size;
}



// Override
CBO.prototype.calculateForClassJava = function($class) {

	var classesCoupled = new Set();

	// Methods called by the methods of $class
	var methodCallChain = Query.searchFromInclusive($class).search("method").search("call").chain();

	//println("\nFunctions Called");
	//functionsCalled.forEach(functionCalled => println(functionCalled.name));

	// Filter functions and operator<< (cout), only methods required
	// var methodsCalled = functionsCalled.filter(func => func.definition && func.definition.record);

	//println("\n Methods Called");
	//methodsCalled.forEach(methodCalled => println(methodCalled.name));

	// do not include self class
	methodCallChain.forEach(methodCallElem=>{
		var classCoupled = methodCallElem["call"].targetType.name;
		//println("Class: "+$class.name );
		//println("method: "+methodCallElem["method"].name );
		//println("Sig: "+methodCallElem["call"].targetType.name+ '::' + methodCallElem["call"].name );
		//println();
		
		if(classCoupled !== $class.name)
			classesCoupled.add(classCoupled); 
  		
	});

	
	//print(classesCoupled.values()+ "\n");

	// Methods that call the methods of $class

	var methodsThatCall = Query.search("method").search("call", {"targetType": targetType => targetType.name === $class.name}).chain();
	//var methodsThatCall = Query.search("method").search("memberCall", 
		//{"definition": d => d.record.name === $class.name}).chain();

	//println("\Methods that call method of class:");
	for(var query of methodsThatCall) {
		if(query["method"].parent.name !== $class.name)
			classesCoupled.add(query["method"].parent.name);

		
		// println();
		// println("Class: "+$class.name );
		// println("Classmethod: "+query["method"].parent.name );
		// println("method: "+query["method"].name );
		// println("Sig: "+query["call"].targetType.name+ '::' + query["call"].name );
		// println();
		

		//println(query["method"].record.name);
		//println();
	}

	

	// // TODO: fields accesses

	// // Fields Accessed by the methods of $class
	// var fieldsAccessed = Query.search("method", {"record": r => r.name === $class.name}).search("memberAccess").get();

	// for(var fieldAccessed of fieldsAccessed) {
	// println("Code: " + fieldAccessed.code);
	// println("Type: " + fieldAccessed.base.type.name);
	// if(fieldAccessed.base.decl !== undefined)
	// 			println("BASE1: " + fieldAccessed.base.decl.name); // this.bar1()
	// 		else
	// 			if (fieldAccessed.base.vardecl !== undefined)
	// 				println("BASE2: " + fieldAccessed.base.vardecl.type.name); // myAnimal.animalSound
	// 			else if (fieldAccessed.base.type.pointee !== undefined)
	// 				println("BASE3: " + fieldAccessed.base.type.pointee.decl.name); // (this->ancestor)->age
	// 			else println("BASE4: " + fieldAccessed.base.type.name); // (this->ancestor).age
	
	// }

	// println();

	








	// ///......................::///

	// // Methods that call the methods of $class
	// var methodsThatCall = Query.search("method").search("memberCall", 
	// 	{"definition": d => d.record.name === $class.name}).chain();

	// //println("\Methods that call method of class:");
	// for(var query of methodsThatCall) {
	// 	if(query["method"].record.name !== $class.name)
	// 		classesCoupled.add(query["method"].record.name);

	// 	//println(query["method"].record.name);
	// 	//println();
	// }


	

	println("Class: " + $class.name);
	println(Array.from(classesCoupled));
	return classesCoupled.size;

	
}


// Override
CBO.prototype.calculateForClassInd = function($class) {
	//println("Class: " + $class.name);

   // The Coupling Between Object classes metric represents the number of classes coupled to a given class. This coupling can happen throuhg:
    // x / method call (TODO check call of constructors)
    // x/ class extends (TODO only checking the superClass)
    // x / properties or parameters
    // x/ method arguments, or return types
    // x / variables in methods

    // Call of constructors


	// CPP TYPES
	//// adjustedType
	//// arrayType
	//// 
	//// 
	//// 
    

    
	var classesCoupled = new Set();
	
    	for (var $method of Query.searchFromInclusive($class).search("method").get()){
    		//println($method.signature);
    		//println($class.methods.length);
		
		var $methodsCalled = MetricQuery.getMethodsCalled($method);
		$methodsCalled = $methodsCalled.filter($methodCalled=> $methodCalled.parent.name !== $class.name);
		for (var $methodCalled of $methodsCalled)
			classesCoupled.add($methodCalled.parent.name);

		var $classesUsed = MetricQuery.usedClasses($method.returnRef);  // TODO : This is gonna explode in Java //TODO:
		$classesUsed.forEach($classUsed => classesCoupled.add($classUsed.name));


	}
	


	for (var $field of Query.searchFromInclusive($class).search("field").get()){
		//println("$field: " + $field);
		//println("$class: " + $class);
		var $classesUsed = MetricQuery.usedClasses($field.typeReference);                      //TODO:
		$classesUsed.forEach($classUsed => classesCoupled.add($classUsed.name));

	}

	for (var $field of Query.searchFrom($class).search("localVariable").get()){         //TODO:
		println("vardecl : " + $field.code);
		println("type : " + $field.typeReference);
		//println("$type : " + $field.type); 
		var $classesUsed = MetricQuery.usedClasses($field.typeReference);       //TODO:
		println("$classesUsed : " + $classesUsed);
		$classesUsed.forEach($classUsed => classesCoupled.add($classUsed.name));

	}

	var $classesInherited = MetricQuery.getSuperClasses($class);
	for ($classInherited of $classesInherited)
		classesCoupled.add($classInherited.name); 
		
	
	// for (var $field of Query.searchFromInclusive($class).search("vardecl").get()){
	// 	var $classesUsed = MetricQuery.usedClasses($field.type);
	// 	$classesUsed.forEach($classUsed => classesCoupled.add($classUsed.name));

	// }
	
		



	
	for (var $field of Query.searchFromInclusive($class).search("field", "myobject4").get()){

		
		// if($field.type.isBuiltin)
		// 	continue;

		// if($field.type.kind === 'RecordType')
		// 	continue;

		
		// if($field.type.isArray)
		// 	continue;

		// if($field.type.kind === 'TemplateTypeParmType')
		// 	continue;

		// if($field.type.isPointer)
		// 	continue;	
		
		//println("Field: " + $field.name);
		//var usedClasses = MetricQuery.usedClasses($field.type);
		//for (usedClass of usedClasses)
			//println('used: ' + usedClass.name);
		
		// for(var $class2 of Query.search("class").get()) {
		// 	if(MetricQuery.usesClass($field.type, $class2))
		// 		println('used: ' + $class2.name);
			
		// }
		
		//println();
		}
		

		
		// println("Field: " + $field.name);
		// println("typeReference: " + $field.typeReference);
		// try{
		// // Java
		// //var decl = $field.typeReference.declaration;

		// // C
		// println("decl: " + $field.decl);
		// println("type: " + $field.type.kind);
		// var decl = $field.type.decl;
		// println(decl);
		// }
		// catch(err) {
		// println(decl);
		// }
		// println();
		

	

	var methodCallChain = Query.searchFromInclusive($class).search("method").search("vardecl").get();

	
	// for (var $vardecl of methodCallChain){
	// 	println("name: " + $vardecl.name);
	// 	println("type: " + $vardecl.type.builtinKind);
	// }
	

	

	
	//println("classesCoupled: " + Array.from(classesCoupled));
	//println();
	return classesCoupled.size;
}

*/
