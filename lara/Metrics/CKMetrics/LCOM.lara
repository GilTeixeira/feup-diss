import Metrics.Metric;
import weaver.Selector;

/**
 * Measures the Lack of Cohesion of Methods
 * @constructor
 */
function LCOM94() {
	var name = "Lack of Cohesion of Methods";
	var sigla = "LCOM94";
	var author = "Chidamber and Kemerer";
	var year = 1994;
	var description = "Lack of Cohesion of Methods (LCOM) describes the lack of cohesion among the methods of a class.";

    // Parent constructor    
    Metric.call(this, name, sigla, author, year, description);
}
	
// Inheritance
LCOM94.prototype = Object.create(Metric.prototype);


// Override
LCOM94.prototype.calculateForClass = function($class) {
	println("	Class: " + $class.name+"\n");

	//if($class.name != 'Pig')
		//return 0;

	// Calculate Field Access by Method
	// TODO : Right now it also includes access to fields of other classes with the same name
	var methodFieldsMap = new Map();
	for($method of $class.methods){
		//println("	Method: " + $method.name+"\n");

	
		//println("	Method: " + $method.body+"\n");
	
		var fieldsAccessed = [];
		//var fieldsAccessesByMethod1 = Query.searchFrom($method.definitionJp,"memberAccess").get(); // Only counts self classes Accesses
		var memberAccesses = Query.searchFrom($method.definitionJp,"memberAccess", {"base": base => base.code === 'this'}).get(); // Only counts self classes Accesses
		//var fieldsAccessesByMethod2 = Query.searchFrom($method.definitionJp,"memberAccess", {"base": base => base.decl !== undefined && base.decl.name === $class.name}).get(); // Should be equivalent to previous

		//println('Number Accesses = ' + fieldsAccessesByMethod.length);
		//println('Number Accesses = ' + fieldsAccessesByMethod2.length);

		for(memberAccess of memberAccesses){
			//if(fieldAccessesByMethod.base.decl === undefined)
			//	continue;				
			//println("METHOD: " + $method.signature);
			//println("CODE: " + fieldAccessesByMethod.getCode());
			//println("BASECODE: " + fieldAccessesByMethod.base.code);
			//println("BASECODE: " + fieldAccessesByMethod.base.type.pointee.decl.name);
			/*
			if(fieldAccessesByMethod.base.decl !== undefined)
				println("BASE: " + fieldAccessesByMethod.base.decl.name);
			else
				println("BASE: " + fieldAccessesByMethod.base.vardecl.type);

			*/
			//println("BASE: " + fieldAccessesByMethod.base.decl.name);
			//println("memberChain: " + fieldAccessesByMethod.memberChain);
			//println("memberChain: " + fieldAccessesByMethod.memberChain.getCode());
			println();

		}
			
		// MemberAccesses to the name of the Access
		memberAccessesNames = memberAccesses.map(jp => jp.name);

		// Only field accesses
		for($field of $class.fields)
			if(memberAccessesNames.includes($field.name))
				fieldsAccessed.push($field.name);

		methodFieldsMap.set($method.name, fieldsAccessed);
			
	}
	
	
	methodFieldsMap.forEach((value, key)=>{
		print("	Method: " + key + "\n");
		print("	Fields: " + value + "\n\n");
	});
	


	// TODO : Consider Methods that access other methods
	var numPairMethodCommomFieldAccess = 0; // Q
	var numPairMethodNoCommomFieldAccess = 0; // P
	
	for (i = 0; i < $class.methods.length; i++)
		for (j = i + 1; j < $class.methods.length; j++){
			var $method1 = $class.methods[i].name;
			var $method2 = $class.methods[j].name;
	
			// Check if methods access the same field
			var commonFields = methodFieldsMap.get($method1).filter(function(value) { 
				return methodFieldsMap.get($method2).indexOf(value) > -1;
	      	});

	      	if(commonFields.length === 0)
	      		numPairMethodNoCommomFieldAccess++;
	      	else numPairMethodCommomFieldAccess++;
			

		}

	// LCOM = |P| - |Q|, if |P| > |Q|
	// LCOM = 0, if |P| <= |Q|
	
	var lcom = Math.max((numPairMethodNoCommomFieldAccess - 
			numPairMethodCommomFieldAccess), 0);
	
	return lcom; 


}

/*
How many fields Accesses?
1
class Foo {
	int id; 
	Foo * self;

	int bar() {
    		return self->id;
   	}  
};
*/