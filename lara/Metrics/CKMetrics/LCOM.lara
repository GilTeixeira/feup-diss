import Metrics.Metric;
import weaver.Selector;

/**
 * Measures the Lack of Cohesion of Methods
 * @constructor
 */
function LCOM94() {
	var name = "Lack of Cohesion of Methods";
	var sigla = "LCOM94";
	var author = "Chidamber and Kemerer";
	var year = 1994;
	var description = "Lack of Cohesion of Methods (LCOM) describes the lack of cohesion among the methods of a class.";

    // Parent constructor    
    Metric.call(this, name, sigla, author, year, description);
}
	
// Inheritance
LCOM94.prototype = Object.create(Metric.prototype);


// Override
LCOM94.prototype.calculateForClass = function($class) {

	// Calculate Field Access by Method
	var methodFieldsMap = new Map();
	for($method of $class.methods){

		var fieldsAccessed = [];
		var memberAccesses = Query.searchFrom($method.definitionJp,"memberAccess", {"base": base => base.code === 'this'}).get(); // Only counts self classes Accesses
		//var fieldsAccessesByMethod2 = Query.searchFrom($method.definitionJp,"memberAccess", {"base": base => base.decl !== undefined && base.decl.name === $class.name}).get(); // Should be equivalent to previous

	
		// MemberAccesses to the name of the Access
		memberAccessesNames = memberAccesses.map(jp => jp.name);

		// Only field accesses
		for($field of $class.fields)
			if(memberAccessesNames.includes($field.name))
				fieldsAccessed.push($field.name);

		methodFieldsMap.set($method.name, fieldsAccessed);
			
	}
	
	
	// TODO : Consider Methods that access other methods
	var numPairMethodCommomFieldAccess = 0; // Q
	var numPairMethodNoCommomFieldAccess = 0; // P
	
	for (i = 0; i < $class.methods.length; i++)
		for (j = i + 1; j < $class.methods.length; j++){
			var $method1 = $class.methods[i].name;
			var $method2 = $class.methods[j].name;
	
			// Check if methods access the same field
			var commonFields = methodFieldsMap.get($method1).filter(function(value) { 
				return methodFieldsMap.get($method2).indexOf(value) > -1;
	      	});

	      	if(commonFields.length === 0)
	      		numPairMethodNoCommomFieldAccess++;
	      	else numPairMethodCommomFieldAccess++;
			

		}

	// LCOM = |P| - |Q|, if |P| > |Q|
	// LCOM = 0, if |P| <= |Q|
	
	var lcom = Math.max((numPairMethodNoCommomFieldAccess - 
			numPairMethodCommomFieldAccess), 0);
	
	return lcom; 


}

/*
How many fields Accesses?
1
class Foo {
	int id; 
	Foo * self;

	int bar() {
    		return self->id;
   	}  
};
*/