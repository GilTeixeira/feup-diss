import Metrics.Metric;
import weaver.Selector;
import Utils.Utils;

/**
 * Measures the Lack of Cohesion of Methods
 * @constructor
 */
function LCOM94() {
	var name = "Lack of Cohesion of Methods";
	var sigla = "LCOM94";
	var author = "Chidamber and Kemerer";
	var year = 1994;
	var description = "Lack of Cohesion of Methods (LCOM) describes the lack of cohesion among the methods of a class.";

    // Parent constructor    
    Metric.call(this, name, sigla, author, year, description);
}
	
// Inheritance
LCOM94.prototype = Object.create(Metric.prototype);


// Override
LCOM94.prototype.calculateForClass = function($class) {
	// Required
	// class.methods : Array of methods


	// Calculate Field Access by Method
	var methodFieldsMap = new Map();
	for($method of $class.methods){

		var fieldsAccessed = [];
		var memberAccesses = Query.searchFrom($method.definitionJp,"memberAccess", {"base": base => base.code === 'this'}).get(); // Only counts self classes Accesses
		//var fieldsAccessesByMethod2 = Query.searchFrom($method.definitionJp,"memberAccess", {"base": base => base.decl !== undefined && base.decl.name === $class.name}).get(); // Should be equivalent to previous

	
		// MemberAccesses to the name of the Access
		memberAccessesNames = memberAccesses.map(jp => jp.name);

		// Only field accesses
		for($field of $class.fields)
			if(memberAccessesNames.includes($field.name))
				fieldsAccessed.push($field.name);

		methodFieldsMap.set($method.name, fieldsAccessed);
			
	}
	
	
	// TODO : Consider Methods that access other methods
	var numPairMethodCommomFieldAccess = 0; // Q
	var numPairMethodNoCommomFieldAccess = 0; // P
	
	for (i = 0; i < $class.methods.length; i++)
		for (j = i + 1; j < $class.methods.length; j++){
			var $method1 = $class.methods[i].name;
			var $method2 = $class.methods[j].name;
	
			// Check if methods access the same field
			var commonFields = methodFieldsMap.get($method1).filter(function(value) { 
				return methodFieldsMap.get($method2).indexOf(value) > -1;
	      	});

	      	if(commonFields.length === 0)
	      		numPairMethodNoCommomFieldAccess++;
	      	else numPairMethodCommomFieldAccess++;
			

		}

	// LCOM = |P| - |Q|, if |P| > |Q|
	// LCOM = 0, if |P| <= |Q|
	
	var lcom = Math.max((numPairMethodNoCommomFieldAccess - 
			numPairMethodCommomFieldAccess), 0);
	
	return lcom; 


}

// Override
LCOM94.prototype.calculateForClassJava = function($class) {
	/*
	var methodFieldsMap = new Map();
	println($class.name);

	for ($method of Query.searchFromInclusive($class).search("method").get()){
		println("	" + $method.name);
		var fieldsAccessed = []; // TODO : Maybe change to Set
		for ($var of Query.searchFromInclusive($method).search("var").get()){
			println("		" + $var.name);
			
				if($var.isField && $var.declaration)  // check if var.decl is  not undefined Ex: (PrintStream)
					if($var.declaration.parent.name === $class.name)
						fieldsAccessed.push($var.declaration.name);
		
		}
		println();

		methodFieldsMap.set($method.name, fieldsAccessed);

	}
	*/ 

	// map method name to set of fields names
	var methodFieldsMap = new Map();
	//println($class.name);

	for (query of Query.searchFromInclusive($class).search("method").search("var").chain()){
		if(query["var"].isField && query["var"].declaration)  // check if var.decl is  not undefined Ex: (PrintStream)
			if(query["var"].declaration.parent.name === $class.name){ // if self acess
				var currMethodName = query["method"].name;
				var currFieldName = query["var"].declaration.name;

				if(methodFieldsMap.has(currMethodName)){
					var currAccessedFields = methodFieldsMap.get(currMethodName);
					currAccessedFields.add(currFieldName);
					methodFieldsMap.set(currMethodName,currAccessedFields);

				}
				else methodFieldsMap.set(currMethodName,new Set([currFieldName]));
		

			}
				

			
		//println("	" + query["method"].name);
		//println("	" + query["var"].name);
		//println("	" + query["var"].parent.srcCode);
		//println();
		//println("	" + query["method"].name);
		

	}
	/**/
	

	

	

	

	//methodFieldsMap.forEach((value,key)=>println("Value: "+ Array.from(value) + " KEy: " + key));


		// TODO : Consider Methods that access other methods
	var numPairMethodCommomFieldAccess = 0; // Q
	var numPairMethodNoCommomFieldAccess = 0; // P

	var $methods = Query.searchFromInclusive($class).search("method").get();

	for ($method of $methods)
		if(!methodFieldsMap.has($method.name))
			methodFieldsMap.set($method.name, new Set());
	
	for (i = 0; i < $methods.length; i++)
		for (j = i + 1; j < $methods.length; j++){
			var $method1 = $methods[i].name;
			var $method2 = $methods[j].name;
	
			// Check if methods access the same field
			var commonFields = Array.from(methodFieldsMap.get($method1)).filter(function(value) { 
				return methodFieldsMap.get($method2).has(value);
	      	});

	      	if(commonFields.length === 0)
	      		numPairMethodNoCommomFieldAccess++;
	      	else numPairMethodCommomFieldAccess++;
			

		}

	// LCOM = |P| - |Q|, if |P| > |Q|
	// LCOM = 0, if |P| <= |Q|
	
	var lcom = Math.max((numPairMethodNoCommomFieldAccess - 
			numPairMethodCommomFieldAccess), 0);
	
	return lcom; 


	return 0;
}

// Override
LCOM94.prototype.calculateForClassInd = function($class) {

	var methodFieldsMap = new Map();
	var $methods = Query.searchFromInclusive($class).search("method").get();
	
	for ($method of $methods){
		var $fieldsAccessed = MetricQuery.getFieldsAccessed($method);
		$fieldsAccessed = $fieldsAccessed.filter($fieldAccessed=> $fieldAccessed.parent.name == $class.name);
		var fieldsAccessedNames = $fieldsAccessed.map($fieldAccessed => $fieldAccessed.name);
		methodFieldsMap.set(MetricQuery.getMethodSignature($method),new Set(fieldsAccessedNames));

	}

	/*
	for ([key, value] of methodFieldsMap.entries()) {
	  println(key + "  " + Array.from(value));
	}
	*/


	var numPairMethodCommomFieldAccess = 0; // Q
	var numPairMethodNoCommomFieldAccess = 0; // P
	
	for (i = 0; i < $methods.length; i++)
		for (j = i + 1; j < $methods.length; j++){
			var method1Signature = MetricQuery.getMethodSignature($methods[i]);
			var method2Signature = MetricQuery.getMethodSignature($methods[j]);

			var commomFieldsSet = intersectionSets(methodFieldsMap.get(method1Signature), methodFieldsMap.get(method2Signature));

			if(commomFieldsSet.size === 0)
	      		numPairMethodNoCommomFieldAccess++;
	      	else numPairMethodCommomFieldAccess++;

		}

	// LCOM = |P| - |Q|, if |P| > |Q|
	// LCOM = 0, if |P| <= |Q|
	
	var lcom = Math.max((numPairMethodNoCommomFieldAccess - 
			numPairMethodCommomFieldAccess), 0);
	
	return lcom; 
}


/*
How many fields Accesses?
1
class Foo {
	int id; 
	Foo * self;

	int bar() {
    		return self->id;
   	}  
};
*/